**Имя:** Козин Вячеслав Викторович

**Группа:** БПМ-22-1

---


# форматы файлов - человекочитаемые – **XML**

**XML** (e**X**tensible **M**arkup **L**anguage) представляет собой язык разметки, предназначенный для хранения и передачи данных.

### Основные цели и назначение

XML разработан для предоставления универсального формата обмена данными между различными системами, позволяя им эффективно передавать и структурировать информацию. С его помощью можно описывать данные в иерархической форме, обеспечивая прозрачность и легкость интерпретации как человеком, так и машинами.
XML широко используется в веб-разработке, конфигурационных файлах, обмене данных между приложениями и других областях, где важна структурированность и расширяемость данных.


1. **Универсальность:**
   XML является универсальным форматом данных, который может представлять практически любой тип информации. Это позволяет использовать его в различных областях, от веб-разработки до обмена данными между различными программами.

2. **Структурирование данных:**
   XML обеспечивает возможность структурирования данных с использованием тегов, что упрощает понимание и интерпретацию информации. Теги могут вкладываться друг в друга, создавая иерархическую структуру.

3. **Расширяемость:**
   XML обладает высокой степенью расширяемости, что позволяет легко адаптировать его для новых потребностей. Это осуществляется путем создания собственных тегов и определения собственных правил разметки.

5. **Web-разработка:**
   XML часто используется в веб-разработке для передачи данных между клиентом и сервером. Например, формат RSS для для описания лент новостей для веб-сервисов основан на XML.

6. **Настройка и хранение конфигураций:**
   XML может быть использован для хранения конфигурационной информации, такой как параметры приложений или настроек системы. Это позволяет легко изменять параметры без необходимости изменения исходного кода программы.

7. **Обмен данными между приложениями:**
   XML является стандартным средством обмена данными между приложениями. Он широко применяется в протоколах обмена данными, таких как REST, SOAP, и других.


### Структура XML

[Источник](https://www.w3.org/TR/REC-xml/#sec-logical-struct)

1. **Элементы (Elements)**
   
   XML-документы формируются в виде деревьев элементов.
   Дерево XML начинается с корневого элемента и разветвляется от корня к дочерним элементам.

   ```xml
   <element_name>
      <!-- Текстовое содержимое или вложенные элементы -->
   </element_name>
   ```
   
2. **Теги (Tags)**
   
   Тег представляет собой метку, которая определяет начало или конец элемента.
   В XML теги записываются с использованием угловых скобок < и >.
   
    ```xml
   <tag> - открывающий тег
   </tag> - закрывающий тег
   ```
3. **Атрибуты (Attributes)**

   Элементы могут иметь атрибуты, предоставляющие дополнительную информацию о элементе.
   Атрибуты задаются в открывающем теге.
   ```xml
   <book genre="fiction">
   </book>
   ```

4. **Текстовое содержимое (Text Content)**
   
   Элементы могут содержать текстовое содержимое между открывающим и закрывающим тегами.
   ```xml
   <element>Текстовое содержимое</element>
   ```
   

5. **Инструкции обработки (Processing Instructions)**
   
   Инструкции обработки предназначены для указания специфических действий при обработке XML документа.
   ```xml
   <?Instruction_name parametr="value"?>
   ```
   


6. **Пространства имён**
   
   Пространства имен используются для избежания конфликтов имен в XML документах.
   Позволяют группировать элементы по определенным контекстам.
   ```xml

     <root xmlns:ns="http://www.example.com">
       <ns:element>Content</ns:element>
     </root>
     ```




## Валидация XML

В контексте XML, валидация представляет собой процесс проверки того, соответствует ли XML-документ определенной структуре или схеме. Это гарантирует, что документ соответствует некоторым ожиданиям и правилам, установленным заранее. Валидация XML особенно полезна при обмене данными между различными системами, поскольку обеспечивает стандартизацию формата данных.

**DTD (Document Type Definition):**

DTD — это один из методов валидации XML. Это формальное описание структуры документа, которое определяет порядок и типы элементов, их атрибуты, а также их взаимосвязи. Вот пример DTD для простого XML-документа:

```xml
<!DOCTYPE bookstore [
  <!ELEMENT bookstore (book+)>
  <!ELEMENT book (title, author, price)>
  <!ELEMENT title (#PCDATA)>
  <!ELEMENT author (#PCDATA)>
  <!ELEMENT price (#PCDATA)>
]>
```

Этот DTD определяет, что корневой элемент — bookstore, который может содержать один или более элементов book. Элемент book, в свою очередь, должен содержать элементы title, author и price, каждый из которых содержит текстовые данные (#PCDATA).

**XSD (XML Schema Definition):**

XSD — более мощный и гибкий способ валидации XML, предоставляющий более развитые средства определения структуры документа. Пример XSD для того же XML-документа:

```xml
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="bookstore">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="book" maxOccurs="unbounded">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="title" type="xs:string"/>
              <xs:element name="author" type="xs:string"/>
              <xs:element name="price" type="xs:float"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
</xs:schema>
```

Этот XSD определяет ту же структуру, что и DTD, но с использованием более сложных и гибких конструкций. Также, XSD может определять ограничения на значения атрибутов, типы данных и другие аспекты.

**Примеры валидации XML:**

При использовании DTD или XSD, вы можете указать ссылку на соответствующий документ в XML-документе:

DTD:

```xml
<!DOCTYPE bookstore SYSTEM "bookstore.dtd">
<bookstore>
  <!-- XML data here -->
</bookstore>
```

XSD:

```xml
<bookstore xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:noNamespaceSchemaLocation="bookstore.xsd">
  <!-- XML data here -->
</bookstore>
```

Если XML-документ не соответствует определенной схеме, процесс валидации выдаст ошибки, указывающие на неверные элементы, атрибуты или структуру. Валидация способствует обеспечению корректного обмена данными и предотвращению ошибок в структуре XML-документов.







   
### Работа с XML в C++

Cуществует много библиотек для работы с XML в С++. Вот некоторые из них:
1. **TinyXML2:**
   
   Это легковесная библиотека для работы с XML в стиле DOM (Document Object Model).
   Она предоставляет простой и удобный интерфейс для чтения и записи XML-документов.
   Ссылка: https://github.com/leethomason/tinyxml2


    Пример простого чтения XML с использованием библиотеки TinyXML2 на C++:

```cpp
#include <iostream>
#include "tinyxml2.h"

int main() {
    // Создаем объект для работы с XML
    tinyxml2::XMLDocument xmlDoc;

    // Загружаем XML-файл
    if (xmlDoc.LoadFile("example.xml") != tinyxml2::XMLError::XML_SUCCESS) {
        std::cerr << "Ошибка загрузки XML-файла." << std::endl;
        return 1;
    }

    // Получаем корневой элемент
    tinyxml2::XMLElement* root = xmlDoc.RootElement();

    // Пример чтения данных из элемента
    const char* value = root->FirstChildElement("ElementName")->GetText();
    std::cout << "Значение элемента: " << value << std::endl;
    return 0;
}

```
2. **Pugixml:**

   - Это эффективная и простая в использовании библиотека для работы с XML.
   - Она также предоставляет DOM-подобный интерфейс.
   - Позволяет использовать Xpath.
   - Доступен в vcpkg
     
   Ссылка: https://github.com/zeux/pugixml
   
```cpp
#include "pugixml.hpp"
#include <iostream>

int main()
{
    pugi::xml_document doc;
    pugi::xml_parse_result result = doc.load_file("xgconsole.xml");
    if (!result)
        return -1;
        
    for (pugi::xml_node tool: doc.child("Profile").child("Tools").children("Tool"))
    {
        int timeout = tool.attribute("Timeout").as_int();
        
        if (timeout > 0)
            std::cout << "Tool " << tool.attribute("Filename").value() << " has timeout " << timeout << "\n";
    }
}
```
И тот же пример с использованием XPath:
```cpp
#include "pugixml.hpp"
#include <iostream>

int main()
{
    pugi::xml_document doc;
    pugi::xml_parse_result result = doc.load_file("xgconsole.xml");
    if (!result)
        return -1;
        
    pugi::xpath_node_set tools_with_timeout = doc.select_nodes("/Profile/Tools/Tool[@Timeout > 0]");
    
    for (pugi::xpath_node node: tools_with_timeout)
    {
        pugi::xml_node tool = node.node();
        std::cout << "Tool " << tool.attribute("Filename").value() <<
            " has timeout " << tool.attribute("Timeout").as_int() << "\n";
    }
}
   ```
